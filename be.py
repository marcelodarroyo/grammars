#!/usr/bin/python

import sys, Lexer, CFG

def combine(l1,l2):
    """
    generate a list from l1 and l2.
    Example: combine([s1,s2],[s3,s4]) == [s1s3,s1s4,s2s3,s2s4]
    """
    if len(l1) == 0:
        return l2
    result = []
    for e in l1:
        for r in l2:
            result.append(e+r)
    return result

def be(grammar, rule, deep):
    """
    Generate a set of strings generated by grammar g, starting from rule until
    the given deep of syntax tree.
    It is a bounded exhaustive generation algoritm.
    """
    if deep == 0:
        return []
    result = []
    for seq in rule.seqs:
        genrule = []
        for sym in seq:
            if isinstance(sym, CFG.Term):
                gen = [sym.tok]
            else:
                if isinstance(sym, CFG.Sym_Term):
                    gen = [sym.tok[3:]] # remove TK_ prefix
                else:
                    if isinstance(sym, CFG.Non_Term_Ref):
                        gen = list(be(grammar, grammar.get_rule(sym.name), deep-1))
            genrule = combine(result, gen)
        result = result + genrule
    return set(result)

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print "Usage: " + sys.argv[0] + " grammar lex unrool-level"
    else:
        l = open(sys.argv[2], "r")
        g = open(sys.argv[1], "r")
        n = int(sys.argv[3])
        lex = Lexer.parse( l.read() )
        grammar = CFG.parse(lex, g.read())
        r = be(grammar, grammar.rules[0], n)
        print r, ": ", len(r)
